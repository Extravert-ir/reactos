/*
 * PROJECT:     Partition manager driver
 * LICENSE:     GPL-2.0-or-later (https://spdx.org/licenses/GPL-2.0-or-later)
 * PURPOSE:     Main file
 * COPYRIGHT:   2020 Victor Perevertkin (victor.perevertkin@reactos.org)
 */

#include "partmgr.h"

VOID
NTAPI
PartMgrUnload(
    _In_ PDRIVER_OBJECT DriverObject)
{

}

static
NTSTATUS
NTAPI
PartMgrAddDevice(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDEVICE_OBJECT PhysicalDeviceObject)
{
    PDEVICE_OBJECT deviceObject;

    NTSTATUS status = IoCreateDevice(
        DriverObject,
        sizeof(FDO_EXTENSION),
        0,
        FILE_DEVICE_BUS_EXTENDER,
        FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
        FALSE,
        &deviceObject);

    if (!NT_SUCCESS(status))
    {
        ERR("[PARTMGR] Failed to create FDO 0x%x\n", status);
        return status;
    }

    PFDO_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension, sizeof(*deviceExtension));

    deviceExtension->IsFDO = TRUE;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->LowerDevice = IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    deviceExtension->PhysicalDiskDO = PhysicalDeviceObject;
    KeInitializeEvent(&deviceExtension->SyncEvent, SynchronizationEvent, TRUE);

    // the the attaching failed
    if (!deviceExtension->LowerDevice)
    {
        IoDeleteDevice(deviceObject);

        return STATUS_DEVICE_REMOVED;
    }
    deviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;

    // device is initialized
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

static
PDRIVE_LAYOUT_INFORMATION
PartMgrConvertExtendedToLayout(
    _In_ CONST PDRIVE_LAYOUT_INFORMATION_EX LayoutEx)
{
    PDRIVE_LAYOUT_INFORMATION Layout;
    PPARTITION_INFORMATION Partition;
    PPARTITION_INFORMATION_EX PartitionEx;

    PAGED_CODE();

    ASSERT(LayoutEx);

    if (LayoutEx->PartitionStyle != PARTITION_STYLE_MBR)
    {
        ASSERT(FALSE);
        return NULL;
    }

    size_t layoutSize = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]) +
                 LayoutEx->PartitionCount * sizeof (PARTITION_INFORMATION);

    Layout = ExAllocatePoolUninitialized(PagedPool, layoutSize, TAG_PARTMGR);

    if (Layout == NULL)
    {
        return NULL;
    }

    Layout->Signature = LayoutEx->Mbr.Signature;
    Layout->PartitionCount = LayoutEx->PartitionCount;

    for (UINT32 i = 0; i < LayoutEx->PartitionCount; i++)
    {
        Partition = &Layout->PartitionEntry[i];
        PartitionEx = &LayoutEx->PartitionEntry[i];

        Partition->StartingOffset = PartitionEx->StartingOffset;
        Partition->PartitionLength = PartitionEx->PartitionLength;
        Partition->RewritePartition = PartitionEx->RewritePartition;
        Partition->PartitionNumber = PartitionEx->PartitionNumber;

        Partition->PartitionType = PartitionEx->Mbr.PartitionType;
        Partition->BootIndicator = PartitionEx->Mbr.BootIndicator;
        Partition->RecognizedPartition = PartitionEx->Mbr.RecognizedPartition;
        Partition->HiddenSectors = PartitionEx->Mbr.HiddenSectors;
    }

    return Layout;
}

static
PDRIVE_LAYOUT_INFORMATION_EX
PartMgrConvertLayoutToExtended(
    _In_ CONST PDRIVE_LAYOUT_INFORMATION Layout)
{
    PDRIVE_LAYOUT_INFORMATION_EX layoutEx;

    PAGED_CODE();

    ASSERT(Layout != NULL);

    size_t layoutSize = FIELD_OFFSET (DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]) +
            Layout->PartitionCount * sizeof ( PARTITION_INFORMATION_EX );

    layoutEx = ExAllocatePoolUninitialized(PagedPool, layoutSize, TAG_PARTMGR);

    if (layoutEx == NULL)
    {
        return NULL;
    }

    layoutEx->PartitionStyle = PARTITION_STYLE_MBR;
    layoutEx->PartitionCount = Layout->PartitionCount;
    layoutEx->Mbr.Signature = Layout->Signature;

    for (UINT32 i = 0; i < Layout->PartitionCount; i++)
    {
        PPARTITION_INFORMATION part = &Layout->PartitionEntry[i];

        layoutEx->PartitionEntry[i] = (PARTITION_INFORMATION_EX) {
            .PartitionStyle = PARTITION_STYLE_MBR,
            .StartingOffset = part->StartingOffset,
            .PartitionLength = part->PartitionLength,
            .RewritePartition = part->RewritePartition,
            .PartitionNumber = part->PartitionNumber,
            .Mbr = {
                .PartitionType = part->PartitionType,
                .BootIndicator = part->BootIndicator,
                .RecognizedPartition = part->RecognizedPartition,
                .HiddenSectors = part->HiddenSectors,
            }
        };
    }

    return layoutEx;
}

static
NTSTATUS
PartMgrUpdateLayout(
    _In_ PFDO_EXTENSION fdoExtension,
    _In_opt_ PDRIVE_LAYOUT_INFORMATION_EX NewLayout)
{
    PDRIVE_LAYOUT_INFORMATION_EX driveLayout;
    NTSTATUS status;
    PSINGLE_LIST_ENTRY curEntry, prevEntry;
    UINT32 totalPartitions = 0;

    if (fdoExtension->LayoutCache)
    {
        ExFreePool(fdoExtension->LayoutCache); // may be NTOS or PARTMGR allocated
    }

    if (!NewLayout)
    {
        status = PartMgrReadPartitionTableEx(fdoExtension, &driveLayout);
        if (!NT_SUCCESS(status))
        {
            ERR("[PARTMGR] IoReadPartitionTableEx failed with status 0x%x\n", status);
            return status;
        }
    }
    else
    {
        driveLayout = NewLayout;
        fdoExtension->LayoutCache = NewLayout;
    }

    fdoExtension->LayoutValid = FALSE;

    // Clear the partition numbers from the list entries
    for (UINT32 i = 0; i < driveLayout->PartitionCount; i++)
    {
        driveLayout->PartitionEntry[i].PartitionNumber = 0;
    }

    // iterate over old partition list
    prevEntry = &fdoExtension->PartitionList;
    curEntry = fdoExtension->PartitionList.Next;
    while (curEntry != NULL)
    {
        PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry, PARTITION_EXTENSION, ListEntry);
        UINT32 partNumber = 0; // count detected partitions for device symlinks
        BOOLEAN found = FALSE;
        PPARTITION_INFORMATION_EX partEntry;

        // trying to find this partition in returned layout
        for (UINT32 i = 0; i < driveLayout->PartitionCount; i++)
        {
            partEntry = &driveLayout->PartitionEntry[i];

            // skip unused and container partitions
            if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR &&
                (partEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                    IsContainerPartition(partEntry->Mbr.PartitionType)))
            {
                continue;
            }

            partNumber++;

            // skip already found partitions
            if (partEntry->PartitionNumber)
            {
                continue;
            }

            // skip if partitions are not equal
            if (partEntry->StartingOffset.QuadPart != partExt->StartingOffset ||
                partEntry->PartitionLength.QuadPart != partExt->PartitionLength)
            {
                continue;
            }

            // found matching partition - processing it
            found = TRUE;
            break;
        }

        if (found)
        {
            // update (possibly changed) partition metadata
            if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR)
            {
                partExt->Mbr.PartitionType = partEntry->Mbr.PartitionType;
                partExt->Mbr.BootIndicator = partEntry->Mbr.BootIndicator;
            }
            else
            {
                partExt->Gpt.PartitionType = partEntry->Gpt.PartitionType;
                partExt->Gpt.PartitionId = partEntry->Gpt.PartitionId;
                partExt->Gpt.Attributes = partEntry->Gpt.Attributes;

                RtlCopyMemory(partExt->Gpt.Name, partEntry->Gpt.Name, sizeof(partExt->Gpt.Name));
            }

            partExt->OnDiskNumber = partNumber;
            partEntry->PartitionNumber = partNumber; // mark it as a found one
            totalPartitions++;
        }
        else
        {
            // detach the device from the list
            prevEntry->Next = curEntry->Next;

            // IoDeleteDevice(partExt->DeviceObject);
        }

        prevEntry = curEntry;
        curEntry = partExt->ListEntry.Next;
    }

    UINT32 partNumber = 0;

    // now looking through remaining "new" partitions
    for (UINT32 i = 0; i < driveLayout->PartitionCount; i++)
    {
        PPARTITION_INFORMATION_EX partEntry = &driveLayout->PartitionEntry[i];

        // again, skip unused and container partitions
        if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR &&
            (partEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                IsContainerPartition(partEntry->Mbr.PartitionType)))
        {
            continue;
        }

        partNumber++;

        // and skip processed partitions
        if (partEntry->PartitionNumber != 0)
        {
            continue;
        }

        // TODO: refactor
        for (LONG ii = 0; ii < (LONG) driveLayout->PartitionCount; ii++)
        {
            PPARTITION_INFORMATION_EX tmp = &(driveLayout->PartitionEntry[ii]);

            if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
                if (tmp->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                    IsContainerPartition(tmp->Mbr.PartitionType)) {
                    continue;
                }
            }

            if(tmp->PartitionNumber == partNumber) {

                // Found a matching partition number - increment the count and restart the scan.

                partNumber++;
                i = -1;
                continue;
            }
        }

        partEntry->PartitionNumber = partNumber;

        PDEVICE_OBJECT partitionDevice;
        status = PartMgrCreatePartitionDevice(
            fdoExtension->DeviceObject, partEntry, (i + 1), driveLayout->PartitionStyle, &partitionDevice);

        if (!NT_SUCCESS(status))
        {
            partEntry->PartitionNumber = 0;
            partNumber--;
            continue;
        }

        totalPartitions++;

        // insert the structure to the partition list
        curEntry = fdoExtension->PartitionList.Next;
        prevEntry = NULL;
        while (curEntry != NULL)
        {
            PPARTITION_EXTENSION curPart = CONTAINING_RECORD(curEntry, PARTITION_EXTENSION, ListEntry);
            if (curPart->MarkRemoved || curPart->DetectedNumber < partNumber)
            {
                prevEntry = curEntry;
                curEntry = curPart->ListEntry.Next;
            }
            else
            { // we found where to put the partition
                break;
            }
        }

        PPARTITION_EXTENSION partExt = partitionDevice->DeviceExtension;

        if (prevEntry)
        {
            // insert after prevEntry
            partExt->ListEntry.Next = prevEntry->Next;
            prevEntry->Next = &partExt->ListEntry;
        }
        else
        {
            // insert in the beginning
            partExt->ListEntry.Next = fdoExtension->PartitionList.Next;
            fdoExtension->PartitionList.Next = &partExt->ListEntry;
        }
    }

    fdoExtension->EnumeratedPartitionsTotal = totalPartitions;
    fdoExtension->LayoutValid = TRUE;

    return STATUS_SUCCESS;
}

static
NTSTATUS
PartMgrRefreshDiskData(
    _In_ PFDO_EXTENSION FDOExtension)
{
    DISK_GEOMETRY_EX_PARTMGR geometryEx2;

    NTSTATUS status = IssueSyncIoControlRequest(
                    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                    FDOExtension->LowerDevice,
                    NULL,
                    0,
                    &geometryEx2,
                    sizeof(geometryEx2),
                    FALSE);

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    FDOExtension->DiskData.PartitionStyle = geometryEx2.Partition.PartitionStyle;
    FDOExtension->DiskData.DiskSize = geometryEx2.DiskSize;
    FDOExtension->DiskData.BytesPerSector = geometryEx2.Geometry.BytesPerSector;
    if (FDOExtension->DiskData.PartitionStyle == PARTITION_STYLE_MBR)
    {
        FDOExtension->DiskData.Mbr.Signature = geometryEx2.Partition.Mbr.Signature;
        // FDOExtension->DiskData.Mbr.Checksum = geometryEx2.Partition.Mbr.CheckSum;
    }
    else
    {
        RtlMoveMemory(
            &FDOExtension->DiskData.Gpt.DiskId,
            &geometryEx2.Partition.Gpt.DiskId,
            sizeof(FDOExtension->DiskData.Gpt.DiskId));
    }

    return STATUS_SUCCESS;
}

/*
 Answer to events:
 GUID_IO_DISK_LAYOUT_CHANGE
 */

static
NTSTATUS
NTAPI
PartMgrDeviceControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    INFO("[PARTMGR] IRP_MJ_DEVICE_CONTROL %p Irp %p IOCTL %x isFdo: %u\n",
        DeviceObject, Irp, ioStack->Parameters.DeviceIoControl.IoControlCode, fdoExtension->IsFDO);

    if (!fdoExtension->IsFDO)
    {
        return PartMgrPartitionDeviceControl(DeviceObject, Irp);
    }

    /* Need to implement:
    IOCTL_DISK_GET_PARTITION_INFO +
    IOCTL_DISK_GET_PARTITION_INFO_EX +
    IOCTL_DISK_GET_DRIVE_LAYOUT
    IOCTL_DISK_SET_DRIVE_LAYOUT
    IOCTL_DISK_GET_DRIVE_LAYOUT_EX
    IOCTL_DISK_SET_DRIVE_LAYOUT_EX
    IOCTL_DISK_UPDATE_PROPERTIES
    IOCTL_DISK_CREATE_DISK
    IOCTL_DISK_DELETE_DRIVE_LAYOUT
    IOCTL_DISK_GROW_PARTITION
    IOCTL_DISK_MEDIA_REMOVAL

    IOCTL_DISK_GET_WRITE_CACHE_STATE // obsolete
    IOCTL_DISK_VERIFY // adjust offset
    IOCTL_DISK_GET_LENGTH_INFO // check if we need to do anything
     */

    switch (ioStack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_DISK_GET_PARTITION_INFO:
        {
            if (!VerifyIrpBufferSize(Irp, sizeof(PARTITION_INFORMATION)))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            PPARTITION_INFORMATION partInfo = Irp->AssociatedIrp.SystemBuffer;

            *partInfo = (PARTITION_INFORMATION){
                .PartitionType = PARTITION_ENTRY_UNUSED,
                .StartingOffset.QuadPart = 0,
                .PartitionLength.QuadPart = fdoExtension->DiskData.DiskSize,
                .HiddenSectors = 0,
                .PartitionNumber = 0,
                .BootIndicator = FALSE,
                .RewritePartition = FALSE,
                .RecognizedPartition = FALSE,
            };

            Irp->IoStatus.Information = sizeof(*partInfo);
            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
        {
            if (!VerifyIrpBufferSize(Irp, sizeof(PARTITION_INFORMATION_EX)))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //TODO: update disk geometry

            PPARTITION_INFORMATION_EX partInfoEx = Irp->AssociatedIrp.SystemBuffer;

            // most of the fields a zeroed for Partition0
            RtlZeroMemory(partInfoEx, sizeof(*partInfoEx));

            partInfoEx->PartitionLength.QuadPart = fdoExtension->DiskData.DiskSize;
            partInfoEx->PartitionStyle = fdoExtension->DiskData.PartitionStyle;

            Irp->IoStatus.Information = sizeof(*partInfoEx);
            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        {
            PartMgrAcquireLayoutLock(fdoExtension);

            SIZE_T size = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]);
            size += fdoExtension->LayoutCache->PartitionCount * sizeof(PARTITION_INFORMATION);

            if (!VerifyIrpBufferSize(Irp, size))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                PartMgrReleaseLayoutLock(fdoExtension);
                break;
            }

            PDRIVE_LAYOUT_INFORMATION partitionList = PartMgrConvertExtendedToLayout(fdoExtension->LayoutCache);

            if (partitionList == NULL)
            {
                Irp->IoStatus.Information = 0;
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlMoveMemory(Irp->AssociatedIrp.SystemBuffer, partitionList, size);

            Irp->IoStatus.Information = size;
            status = STATUS_SUCCESS;
            PartMgrReleaseLayoutLock(fdoExtension);
            break;
        }
        case IOCTL_DISK_SET_DRIVE_LAYOUT:
        {
            // todo: check buffers

            PDRIVE_LAYOUT_INFORMATION layoutInfo = Irp->AssociatedIrp.SystemBuffer;
            // SIZE_T layoutLength = ioStack->Parameters.DeviceIoControl.InputBufferLength;

            PDRIVE_LAYOUT_INFORMATION_EX layoutEx = PartMgrConvertLayoutToExtended(layoutInfo);

            if (layoutEx == NULL)
            {
                Irp->IoStatus.Information = 0;
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            PartMgrAcquireLayoutLock(fdoExtension);

            // now update our layout cache

            status = PartMgrUpdateLayout(fdoExtension, layoutEx);
            if (!NT_SUCCESS(status))
            {
                ASSERT(FALSE); // the function cannot fail when layout is already supplied
                break;
            }

            // write the partition table to the disk

            status = IoWritePartitionTableEx(fdoExtension->LowerDevice, layoutEx);

            if (!NT_SUCCESS(status))
            {
                ASSERT(FALSE);
                break;
            }

            // set updated partition numbers

            for (UINT32 i = 0; i < layoutInfo->PartitionCount; i++)
            {
                PPARTITION_INFORMATION part = &layoutInfo->PartitionEntry[i];

                part->PartitionNumber = layoutEx->PartitionEntry[i].PartitionNumber;
            }

            PartMgrReleaseLayoutLock(fdoExtension);

            IoInvalidateDeviceRelations(fdoExtension->PhysicalDiskDO, BusRelations);

            // todo: verify (update partition numbers?)
            Irp->IoStatus.Information = ioStack->Parameters.DeviceIoControl.OutputBufferLength;
            break;
        }
        default:
            return ForwardIrpAndForget(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

static
NTSTATUS
NTAPI
PartMgrPnp(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PAGED_CODE();

    BOOLEAN isFdo = *(PBOOLEAN)DeviceObject->DeviceExtension;
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0;
    NTSTATUS status;

    INFO("[PARTMGR] IRP_MJ_PNP %p Irp %p %s isFDO: %u\n",
        DeviceObject, Irp, GetIRPMinorFunctionString(ioStack->MinorFunction), isFdo);

    if (!isFdo)
    {
        return PartMgrPartitionHandlePnp(DeviceObject, Irp);
    }

        switch (ioStack->MinorFunction) {

            case IRP_MN_START_DEVICE:
            {
                STORAGE_DEVICE_NUMBER deviceNumber;

                // if this is sent to the FDO we should forward it down the
                // attachment chain before we start the FDO.

                if (!IoForwardIrpSynchronously(fdoExtension->LowerDevice, Irp))
                {
                    status = STATUS_UNSUCCESSFUL;
                    break;
                }

                status = Irp->IoStatus.Status;

                if (!NT_SUCCESS(status))
                {
                    break;
                }

                status = PartMgrRefreshDiskData(fdoExtension);

                if (!NT_SUCCESS(status))
                {
                    break;
                }

                // obtain the disk device number
                status = IssueSyncIoControlRequest(
                    IOCTL_STORAGE_GET_DEVICE_NUMBER,
                    fdoExtension->LowerDevice,
                    NULL,
                    0,
                    &deviceNumber,
                    sizeof(deviceNumber),
                    FALSE);

                if (!NT_SUCCESS(status))
                {
                    break;
                }

                INFO("[PARTMGR] Partition style %u\n", fdoExtension->DiskData.PartitionStyle);

                fdoExtension->DiskData.DeviceNumber = deviceNumber.DeviceNumber;
                fdoExtension->LayoutValid = FALSE;

                break;
            }
            // case IRP_MN_REMOVE_DEVICE:
            // {
            //     // for (PSINGLE_LIST_ENTRY curEntry = fdoExtension->PartitionList.Next;
            //     //      curEntry != NULL;
            //     //      curEntry = curEntry->Next)
            //     // {
            //     //     PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry, PARTITION_EXTENSION, ListEntry);

            //     //     IoDeleteDevice(partExt->DeviceObject);
            //     // }

            //     // Send the IRP down the stack
            //     IoSkipCurrentIrpStackLocation(Irp);
            //     Irp->IoStatus.Status = STATUS_SUCCESS;
            //     status = IoCallDriver(fdoExtension->LowerDevice, Irp);

            //     IoDetachDevice(fdoExtension->LowerDevice);
            //     IoDeleteDevice(DeviceObject);
            //     return status;
            // }
            case IRP_MN_QUERY_DEVICE_RELATIONS:
            {
                DEVICE_RELATION_TYPE type = ioStack->Parameters.QueryDeviceRelations.Type;

                if (type == BusRelations)
                {
                    PartMgrAcquireLayoutLock(fdoExtension);

                    status = PartMgrUpdateLayout(fdoExtension, NULL);

                    if (!NT_SUCCESS(status))
                    {
                        break;
                    }

                    // now fill the DeviceRelations structure
                    TRACE("[PARTMGR] Reporting %u partitions\n",
                        fdoExtension->EnumeratedPartitionsTotal);

                    PDEVICE_RELATIONS deviceRelations = ExAllocatePoolZero(
                        PagedPool, sizeof(DEVICE_RELATIONS) + sizeof(PDEVICE_OBJECT) * (fdoExtension->EnumeratedPartitionsTotal - 1), TAG_PARTMGR);

                    if (!deviceRelations)
                    {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    PSINGLE_LIST_ENTRY curEntry = fdoExtension->PartitionList.Next;
                    while (curEntry != NULL)
                    {
                        PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry, PARTITION_EXTENSION, ListEntry);

                        deviceRelations->Objects[deviceRelations->Count++] = partExt->DeviceObject;
                        ObReferenceObject(partExt->DeviceObject);

                        curEntry = partExt->ListEntry.Next;
                    }

                    ASSERT(deviceRelations->Count == fdoExtension->EnumeratedPartitionsTotal);

                    PartMgrReleaseLayoutLock(fdoExtension);

                    Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
                    Irp->IoStatus.Status = STATUS_SUCCESS;
                }

                IoCopyCurrentIrpStackLocationToNext(Irp);
                return IoCallDriver(fdoExtension->LowerDevice, Irp);
            }
            default: {
                IoSkipCurrentIrpStackLocation(Irp);
                return IoCallDriver(fdoExtension->LowerDevice, Irp);
            }
        }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

static
NTSTATUS
NTAPI
PartMgrReadWrite(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PPARTITION_EXTENSION partExt = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp);

    if (!partExt->IsFDO)
    {
        ioStack->Parameters.Read.ByteOffset.QuadPart += partExt->StartingOffset;
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }
    else
    {
        IoSkipCurrentIrpStackLocation(Irp);
    }

    return IoCallDriver(partExt->LowerDevice, Irp);
}

NTSTATUS
NTAPI
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath)
{
    PVOID DriverExtension;
    NTSTATUS status = IoAllocateDriverObjectExtension(DriverObject, DriverObject, 0, &DriverExtension);

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    DriverObject->DriverUnload = PartMgrUnload;
    DriverObject->DriverExtension->AddDevice = PartMgrAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = ForwardIrpAndForget;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = ForwardIrpAndForget;
    DriverObject->MajorFunction[IRP_MJ_READ]           = PartMgrReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = PartMgrReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PartMgrDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = PartMgrPnp;

    WARN("[PARTMGR] ReactOS Partition manager driver v 0.0.1\n");
    return STATUS_SUCCESS;
}
