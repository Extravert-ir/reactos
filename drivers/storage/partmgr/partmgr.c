/*
 * PROJECT:     Partition manager driver
 * LICENSE:     GPL-2.0-or-later (https://spdx.org/licenses/GPL-2.0-or-later)
 * PURPOSE:     Main file
 * COPYRIGHT:   2020 Victor Perevertkin (victor.perevertkin@reactos.org)
 */

#include "partmgr.h"

VOID
NTAPI
PartMgrUnload(
    _In_ PDRIVER_OBJECT DriverObject)
{

}

static
NTSTATUS
NTAPI
PartMgrAddDevice(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PDEVICE_OBJECT PhysicalDeviceObject)
{
    PDEVICE_OBJECT deviceObject;

    NTSTATUS status = IoCreateDevice(DriverObject,
                                     sizeof(FDO_EXTENSION),
                                     0,
                                     FILE_DEVICE_BUS_EXTENDER,
                                     FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
                                     FALSE,
                                     &deviceObject);

    if (!NT_SUCCESS(status))
    {
        ERR("Failed to create FDO 0x%x\n", status);
        return status;
    }

    PFDO_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    RtlZeroMemory(deviceExtension, sizeof(*deviceExtension));

    deviceExtension->IsFDO = TRUE;
    deviceExtension->DeviceObject = deviceObject;
    deviceExtension->LowerDevice = IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
    deviceExtension->PhysicalDiskDO = PhysicalDeviceObject;
    KeInitializeEvent(&deviceExtension->SyncEvent, SynchronizationEvent, TRUE);

    // the the attaching failed
    if (!deviceExtension->LowerDevice)
    {
        IoDeleteDevice(deviceObject);

        return STATUS_DEVICE_REMOVED;
    }
    deviceObject->Flags |= DO_DIRECT_IO | DO_POWER_PAGABLE;

    // device is initialized
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    return STATUS_SUCCESS;
}

static
PDRIVE_LAYOUT_INFORMATION
PartMgrConvertExtendedToLayout(
    _In_ CONST PDRIVE_LAYOUT_INFORMATION_EX LayoutEx)
{
    PDRIVE_LAYOUT_INFORMATION Layout;
    PPARTITION_INFORMATION Partition;
    PPARTITION_INFORMATION_EX PartitionEx;

    PAGED_CODE();

    ASSERT(LayoutEx);

    if (LayoutEx->PartitionStyle != PARTITION_STYLE_MBR)
    {
        ASSERT(FALSE);
        return NULL;
    }

    size_t layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]) +
                        LayoutEx->PartitionCount * sizeof (PARTITION_INFORMATION);

    Layout = ExAllocatePoolWithTag(PagedPool, layoutSize, TAG_PARTMGR);

    if (Layout == NULL)
    {
        return NULL;
    }

    Layout->Signature = LayoutEx->Mbr.Signature;
    Layout->PartitionCount = LayoutEx->PartitionCount;

    for (UINT32 i = 0; i < LayoutEx->PartitionCount; i++)
    {
        Partition = &Layout->PartitionEntry[i];
        PartitionEx = &LayoutEx->PartitionEntry[i];

        Partition->StartingOffset = PartitionEx->StartingOffset;
        Partition->PartitionLength = PartitionEx->PartitionLength;
        Partition->RewritePartition = PartitionEx->RewritePartition;
        Partition->PartitionNumber = PartitionEx->PartitionNumber;

        Partition->PartitionType = PartitionEx->Mbr.PartitionType;
        Partition->BootIndicator = PartitionEx->Mbr.BootIndicator;
        Partition->RecognizedPartition = PartitionEx->Mbr.RecognizedPartition;
        Partition->HiddenSectors = PartitionEx->Mbr.HiddenSectors;
    }

    return Layout;
}

static
PDRIVE_LAYOUT_INFORMATION_EX
PartMgrConvertLayoutToExtended(
    _In_ CONST PDRIVE_LAYOUT_INFORMATION Layout)
{
    PDRIVE_LAYOUT_INFORMATION_EX layoutEx;

    PAGED_CODE();

    ASSERT(Layout != NULL);

    size_t layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]) +
                        Layout->PartitionCount * sizeof (PARTITION_INFORMATION_EX);

    layoutEx = ExAllocatePoolUninitialized(PagedPool, layoutSize, TAG_PARTMGR);

    if (layoutEx == NULL)
    {
        return NULL;
    }

    layoutEx->PartitionStyle = PARTITION_STYLE_MBR;
    layoutEx->PartitionCount = Layout->PartitionCount;
    layoutEx->Mbr.Signature = Layout->Signature;

    for (UINT32 i = 0; i < Layout->PartitionCount; i++)
    {
        PPARTITION_INFORMATION part = &Layout->PartitionEntry[i];

        layoutEx->PartitionEntry[i] = (PARTITION_INFORMATION_EX) {
            .PartitionStyle = PARTITION_STYLE_MBR,
            .StartingOffset = part->StartingOffset,
            .PartitionLength = part->PartitionLength,
            .RewritePartition = part->RewritePartition,
            .PartitionNumber = part->PartitionNumber,
            .Mbr = {
                .PartitionType = part->PartitionType,
                .BootIndicator = part->BootIndicator,
                .RecognizedPartition = part->RecognizedPartition,
                .HiddenSectors = part->HiddenSectors,
            }
        };
    }

    return layoutEx;
}

static
NTSTATUS
PartMgrUpdateLayout(
    _In_ PFDO_EXTENSION fdoExtension,
    _In_opt_ PDRIVE_LAYOUT_INFORMATION_EX NewLayout)
{
    PDRIVE_LAYOUT_INFORMATION_EX driveLayout;
    NTSTATUS status;
    PSINGLE_LIST_ENTRY curEntry, prevEntry;
    UINT32 totalPartitions = 0;

    if (fdoExtension->LayoutCache)
    {
        ExFreePool(fdoExtension->LayoutCache); // may be NTOS or PARTMGR allocated
    }

    if (!NewLayout)
    {
        status = PartMgrReadPartitionTableEx(fdoExtension, &driveLayout);
        if (!NT_SUCCESS(status))
        {
            ERR("IoReadPartitionTableEx failed with status 0x%x\n", status);
            return status;
        }
    }
    else
    {
        driveLayout = NewLayout;
        fdoExtension->LayoutCache = NewLayout;
    }

    fdoExtension->LayoutValid = FALSE;

    // Clear the partition numbers from the list entries
    for (INT i = 0; i < driveLayout->PartitionCount; i++)
    {
        driveLayout->PartitionEntry[i].PartitionNumber = 0;
    }

    // iterate over old partition list
    prevEntry = &fdoExtension->PartitionList;
    curEntry = fdoExtension->PartitionList.Next;
    while (curEntry != NULL)
    {
        PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry, PARTITION_EXTENSION, ListEntry);
        UINT32 partNumber = 0; // count detected partitions for device symlinks
        BOOLEAN found = FALSE;
        PPARTITION_INFORMATION_EX partEntry;

        // trying to find this partition in returned layout
        for (INT i = 0; i < driveLayout->PartitionCount; i++)
        {
            partEntry = &driveLayout->PartitionEntry[i];

            // skip unused and container partitions
            if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR &&
                (partEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                    IsContainerPartition(partEntry->Mbr.PartitionType)))
            {
                continue;
            }

            partNumber++;

            // skip already found partitions
            if (partEntry->PartitionNumber)
            {
                continue;
            }

            // skip if partitions are not equal
            if (partEntry->StartingOffset.QuadPart != partExt->StartingOffset ||
                partEntry->PartitionLength.QuadPart != partExt->PartitionLength)
            {
                continue;
            }

            // found matching partition - processing it
            found = TRUE;
            break;
        }

        if (found)
        {
            // update (possibly changed) partition metadata
            if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR)
            {
                partExt->Mbr.PartitionType = partEntry->Mbr.PartitionType;
                partExt->Mbr.BootIndicator = partEntry->Mbr.BootIndicator;
            }
            else
            {
                partExt->Gpt.PartitionType = partEntry->Gpt.PartitionType;
                partExt->Gpt.PartitionId = partEntry->Gpt.PartitionId;
                partExt->Gpt.Attributes = partEntry->Gpt.Attributes;

                RtlCopyMemory(partExt->Gpt.Name, partEntry->Gpt.Name, sizeof(partExt->Gpt.Name));
            }

            partExt->OnDiskNumber = partNumber;
            partEntry->PartitionNumber = partNumber; // mark it as a found one
            totalPartitions++;
        }
        else
        {
            // detach the device from the list
            prevEntry->Next = curEntry->Next;
            curEntry = prevEntry;
            partExt->Attached = FALSE;

            // enumerated PDOs will receive IRP_MN_REMOVE_DEVICE
            if (!partExt->IsEnumerated)
            {
                PartMgrRemovePartition(partExt, TRUE);
            }
        }

        prevEntry = curEntry;
        curEntry = curEntry->Next;
    }

    UINT32 partNumber = 0;

    // now looking through remaining "new" partitions
    for (INT i = 0; i < driveLayout->PartitionCount; i++)
    {
        PPARTITION_INFORMATION_EX partEntry = &driveLayout->PartitionEntry[i];

        // again, skip unused and container partitions
        if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR &&
            (partEntry->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                IsContainerPartition(partEntry->Mbr.PartitionType)))
        {
            continue;
        }

        partNumber++;

        // and skip processed partitions
        if (partEntry->PartitionNumber != 0)
        {
            continue;
        }

        // TODO: refactor
        for (INT ii = 0; ii < (INT)driveLayout->PartitionCount; ii++)
        {
            PPARTITION_INFORMATION_EX tmp = &(driveLayout->PartitionEntry[ii]);

            if (driveLayout->PartitionStyle == PARTITION_STYLE_MBR) {
                if (tmp->Mbr.PartitionType == PARTITION_ENTRY_UNUSED ||
                    IsContainerPartition(tmp->Mbr.PartitionType)) {
                    continue;
                }
            }

            if(tmp->PartitionNumber == partNumber) {

                // Found a matching partition number - increment the count and restart the scan.

                partNumber++;
                i = -1;
                continue;
            }
        }

        partEntry->PartitionNumber = partNumber;

        PDEVICE_OBJECT partitionDevice;
        status = PartMgrCreatePartitionDevice(fdoExtension->DeviceObject,
                                              partEntry,
                                              i + 1,
                                              driveLayout->PartitionStyle,
                                              &partitionDevice);

        if (!NT_SUCCESS(status))
        {
            partEntry->PartitionNumber = 0;
            partNumber--;
            continue;
        }

        totalPartitions++;

        // insert the structure to the partition list
        curEntry = fdoExtension->PartitionList.Next;
        prevEntry = NULL;
        while (curEntry != NULL)
        {
            PPARTITION_EXTENSION curPart = CONTAINING_RECORD(curEntry,
                                                             PARTITION_EXTENSION,
                                                             ListEntry);
            if (curPart->DetectedNumber < partNumber)
            {
                prevEntry = curEntry;
                curEntry = curPart->ListEntry.Next;
            }
            else
            { // we found where to put the partition
                break;
            }
        }

        PPARTITION_EXTENSION partExt = partitionDevice->DeviceExtension;

        if (prevEntry)
        {
            // insert after prevEntry
            partExt->ListEntry.Next = prevEntry->Next;
            prevEntry->Next = &partExt->ListEntry;
        }
        else
        {
            // insert in the beginning
            partExt->ListEntry.Next = fdoExtension->PartitionList.Next;
            fdoExtension->PartitionList.Next = &partExt->ListEntry;
        }

        partExt->Attached = TRUE;
    }

    fdoExtension->EnumeratedPartitionsTotal = totalPartitions;
    fdoExtension->LayoutValid = TRUE;

    return STATUS_SUCCESS;
}

static
NTSTATUS
PartMgrRefreshDiskData(
    _In_ PFDO_EXTENSION FDOExtension)
{
    DISK_GEOMETRY_EX_PARTMGR geometryEx2;

    NTSTATUS status = IssueSyncIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
                                                FDOExtension->LowerDevice,
                                                NULL,
                                                0,
                                                &geometryEx2,
                                                sizeof(geometryEx2),
                                                FALSE);

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    FDOExtension->DiskData.PartitionStyle = geometryEx2.Partition.PartitionStyle;
    FDOExtension->DiskData.DiskSize = geometryEx2.DiskSize;
    FDOExtension->DiskData.BytesPerSector = geometryEx2.Geometry.BytesPerSector;
    if (FDOExtension->DiskData.PartitionStyle == PARTITION_STYLE_MBR)
    {
        FDOExtension->DiskData.Mbr.Signature = geometryEx2.Partition.Mbr.Signature;
        // FDOExtension->DiskData.Mbr.Checksum = geometryEx2.Partition.Mbr.CheckSum;
    }
    else
    {
        RtlMoveMemory(&FDOExtension->DiskData.Gpt.DiskId,
                      &geometryEx2.Partition.Gpt.DiskId,
                      sizeof(FDOExtension->DiskData.Gpt.DiskId));
    }

    return STATUS_SUCCESS;
}

static
NTSTATUS
NTAPI
PartMgrDeviceControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    INFO("IRP_MJ_DEVICE_CONTROL %p Irp %p IOCTL %x isFdo: %u\n",
        DeviceObject, Irp, ioStack->Parameters.DeviceIoControl.IoControlCode, fdoExtension->IsFDO);

    if (!fdoExtension->IsFDO)
    {
        return PartMgrPartitionDeviceControl(DeviceObject, Irp);
    }

    switch (ioStack->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_DISK_GET_PARTITION_INFO:
        {
            PPARTITION_INFORMATION partInfo = Irp->AssociatedIrp.SystemBuffer;

            if (!VerifyIrpOutBufferSize(Irp, sizeof(*partInfo)))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            *partInfo = (PARTITION_INFORMATION){
                .PartitionType = PARTITION_ENTRY_UNUSED,
                .StartingOffset.QuadPart = 0,
                .PartitionLength.QuadPart = fdoExtension->DiskData.DiskSize,
                .HiddenSectors = 0,
                .PartitionNumber = 0,
                .BootIndicator = FALSE,
                .RewritePartition = FALSE,
                .RecognizedPartition = FALSE,
            };

            Irp->IoStatus.Information = sizeof(*partInfo);
            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_GET_PARTITION_INFO_EX:
        {
            PPARTITION_INFORMATION_EX partInfoEx = Irp->AssociatedIrp.SystemBuffer;

            if (!VerifyIrpOutBufferSize(Irp, sizeof(*partInfoEx)))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            // most of the fields a zeroed for Partition0
            *partInfoEx = (PARTITION_INFORMATION_EX){
                .PartitionLength.QuadPart = fdoExtension->DiskData.DiskSize,
                .PartitionStyle = fdoExtension->DiskData.PartitionStyle,
            };

            Irp->IoStatus.Information = sizeof(*partInfoEx);
            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_GET_DRIVE_LAYOUT:
        {
            PartMgrAcquireLayoutLock(fdoExtension);

            size_t size = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]);
            size += fdoExtension->LayoutCache->PartitionCount * sizeof(PARTITION_INFORMATION);

            if (!VerifyIrpOutBufferSize(Irp, size))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                PartMgrReleaseLayoutLock(fdoExtension);
                break;
            }

            PDRIVE_LAYOUT_INFORMATION partitionList =
                PartMgrConvertExtendedToLayout(fdoExtension->LayoutCache);

            PartMgrReleaseLayoutLock(fdoExtension);

            if (partitionList == NULL)
            {
                Irp->IoStatus.Information = 0;
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlMoveMemory(Irp->AssociatedIrp.SystemBuffer, partitionList, size);
            ExFreePoolWithTag(partitionList, TAG_PARTMGR);

            Irp->IoStatus.Information = size;
            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
        {
            PartMgrAcquireLayoutLock(fdoExtension);

            size_t size = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]);
            size += fdoExtension->LayoutCache->PartitionCount * sizeof(PARTITION_INFORMATION_EX);

            if (!VerifyIrpOutBufferSize(Irp, size))
            {
                status = STATUS_BUFFER_TOO_SMALL;
                PartMgrReleaseLayoutLock(fdoExtension);
                break;
            }

            RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer, fdoExtension->LayoutCache, size);

            PartMgrReleaseLayoutLock(fdoExtension);

            Irp->IoStatus.Information = size;
            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_SET_DRIVE_LAYOUT:
        {
            PDRIVE_LAYOUT_INFORMATION layoutInfo = Irp->AssociatedIrp.SystemBuffer;

            if (!VerifyIrpInBufferSize(Irp, sizeof(*layoutInfo)))
            {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            size_t layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION, PartitionEntry[0]);
            layoutSize += layoutInfo->PartitionCount * sizeof(PARTITION_INFORMATION);

            if (!VerifyIrpInBufferSize(Irp, layoutSize))
            {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            PDRIVE_LAYOUT_INFORMATION_EX layoutEx = PartMgrConvertLayoutToExtended(layoutInfo);

            if (layoutEx == NULL)
            {
                Irp->IoStatus.Information = 0;
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            PartMgrAcquireLayoutLock(fdoExtension);

            // now update our layout cache
            status = PartMgrUpdateLayout(fdoExtension, layoutEx);
            if (!NT_SUCCESS(status))
            {
                ASSERT(FALSE); // the function cannot fail when layout is already supplied
            }

            // write the partition table to the disk
            status = IoWritePartitionTableEx(fdoExtension->LowerDevice, layoutEx);

            if (!NT_SUCCESS(status))
            {
                ASSERT(FALSE);
                break;
            }

            // set updated partition numbers
            for (INT i = 0; i < layoutInfo->PartitionCount; i++)
            {
                PPARTITION_INFORMATION part = &layoutInfo->PartitionEntry[i];

                part->PartitionNumber = layoutEx->PartitionEntry[i].PartitionNumber;
            }

            PartMgrReleaseLayoutLock(fdoExtension);

            IoInvalidateDeviceRelations(fdoExtension->PhysicalDiskDO, BusRelations);

            // notify everyone that the disk layout has changed
            TARGET_DEVICE_CUSTOM_NOTIFICATION notification;

            notification.Event = GUID_IO_DISK_LAYOUT_CHANGE;
            notification.Version = 1;
            notification.Size = FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);
            notification.FileObject = NULL;
            notification.NameBufferOffset = -1;

            IoReportTargetDeviceChangeAsynchronous(fdoExtension->PhysicalDiskDO,
                                                   &notification,
                                                   NULL,
                                                   NULL);

            Irp->IoStatus.Information = layoutSize;
            break;
        }
        case IOCTL_DISK_SET_DRIVE_LAYOUT_EX:
        {
            PDRIVE_LAYOUT_INFORMATION_EX layoutEx2,
                layoutEx = Irp->AssociatedIrp.SystemBuffer;

            if (!VerifyIrpInBufferSize(Irp, sizeof(*layoutEx)))
            {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            size_t layoutSize = FIELD_OFFSET(DRIVE_LAYOUT_INFORMATION_EX, PartitionEntry[0]);
            layoutSize += layoutEx->PartitionCount * sizeof(PARTITION_INFORMATION_EX);

            if (!VerifyIrpInBufferSize(Irp, layoutSize))
            {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            // we need to copy the structure from the IRP input buffer
            layoutEx2 = ExAllocatePoolWithTag(PagedPool, layoutSize, TAG_PARTMGR);
            if (!layoutEx2)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                Irp->IoStatus.Information = 0;
                break;
            }

            RtlCopyMemory(layoutEx2, layoutEx, layoutSize);

            PartMgrAcquireLayoutLock(fdoExtension);

            // now update our layout cache
            status = PartMgrUpdateLayout(fdoExtension, layoutEx2);
            if (!NT_SUCCESS(status))
            {
                ASSERT(FALSE); // the function cannot fail when layout is already supplied
            }

            // write the partition table to the disk
            status = IoWritePartitionTableEx(fdoExtension->LowerDevice, layoutEx2);

            if (!NT_SUCCESS(status))
            {
                ASSERT(FALSE);
                break;
            }

            // set updated partition numbers
            for (INT i = 0; i < layoutEx2->PartitionCount; i++)
            {
                PPARTITION_INFORMATION_EX part = &layoutEx->PartitionEntry[i];

                part->PartitionNumber = layoutEx2->PartitionEntry[i].PartitionNumber;
            }

            PartMgrReleaseLayoutLock(fdoExtension);

            IoInvalidateDeviceRelations(fdoExtension->PhysicalDiskDO, BusRelations);

            // notify everyone that the disk layout has changed
            TARGET_DEVICE_CUSTOM_NOTIFICATION notification;

            notification.Event = GUID_IO_DISK_LAYOUT_CHANGE;
            notification.Version = 1;
            notification.Size = FIELD_OFFSET(TARGET_DEVICE_CUSTOM_NOTIFICATION, CustomDataBuffer);
            notification.FileObject = NULL;
            notification.NameBufferOffset = -1;

            IoReportTargetDeviceChangeAsynchronous(fdoExtension->PhysicalDiskDO,
                                                   &notification,
                                                   NULL,
                                                   NULL);

            Irp->IoStatus.Information = layoutSize;
            break;
        }
        case IOCTL_DISK_UPDATE_PROPERTIES:
        {
            fdoExtension->LayoutValid = FALSE;
            IoInvalidateDeviceRelations(fdoExtension->PhysicalDiskDO, BusRelations);

            status = STATUS_SUCCESS;
            break;
        }
        case IOCTL_DISK_CREATE_DISK:
        {
            PCREATE_DISK createDisk = Irp->AssociatedIrp.SystemBuffer;
            if (!VerifyIrpInBufferSize(Irp, sizeof(*createDisk)))
            {
                status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            fdoExtension->LayoutValid = FALSE;

            status = IoCreateDisk(fdoExtension->LowerDevice, createDisk);

            IoInvalidateDeviceRelations(fdoExtension->PhysicalDiskDO, BusRelations);
            break;
        }
        case IOCTL_DISK_DELETE_DRIVE_LAYOUT:
        {
            fdoExtension->LayoutValid = FALSE;

            CREATE_DISK createDisk = { .PartitionStyle = PARTITION_STYLE_RAW };

            status = IoCreateDisk(fdoExtension->LowerDevice, &createDisk);

            IoInvalidateDeviceRelations(fdoExtension->PhysicalDiskDO, BusRelations);
            break;
        }
        // case IOCTL_DISK_GROW_PARTITION: // todo
        default:
            return ForwardIrpAndForget(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

static
NTSTATUS
NTAPI
PartMgrPnp(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PAGED_CODE();

    BOOLEAN isFdo = *(PBOOLEAN)DeviceObject->DeviceExtension;
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp);
    Irp->IoStatus.Information = 0;
    NTSTATUS status;

    INFO("IRP_MJ_PNP %p Irp %p %s isFDO: %u\n",
        DeviceObject, Irp, GetIRPMinorFunctionString(ioStack->MinorFunction), isFdo);

    if (!isFdo)
    {
        return PartMgrPartitionHandlePnp(DeviceObject, Irp);
    }

    switch (ioStack->MinorFunction) {

        case IRP_MN_START_DEVICE:
        {
            // if this is sent to the FDO so we should forward it down the
            // attachment chain before we can start the FDO

            if (!IoForwardIrpSynchronously(fdoExtension->LowerDevice, Irp))
            {
                status = STATUS_UNSUCCESSFUL;
                break;
            }

            status = Irp->IoStatus.Status;

            if (!NT_SUCCESS(status))
            {
                break;
            }

            status = PartMgrRefreshDiskData(fdoExtension);

            if (!NT_SUCCESS(status))
            {
                break;
            }

            STORAGE_DEVICE_NUMBER deviceNumber;

            // obtain the disk device number
            status = IssueSyncIoControlRequest(IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                               fdoExtension->LowerDevice,
                                               NULL,
                                               0,
                                               &deviceNumber,
                                               sizeof(deviceNumber),
                                               FALSE);

            if (!NT_SUCCESS(status))
            {
                break;
            }

            INFO("Partition style %u\n", fdoExtension->DiskData.PartitionStyle);

            fdoExtension->DiskData.DeviceNumber = deviceNumber.DeviceNumber;
            fdoExtension->LayoutValid = FALSE;

            break;
        }
        case IRP_MN_QUERY_DEVICE_RELATIONS:
        {
            DEVICE_RELATION_TYPE type = ioStack->Parameters.QueryDeviceRelations.Type;

            if (type == BusRelations)
            {
                PartMgrAcquireLayoutLock(fdoExtension);

                status = PartMgrUpdateLayout(fdoExtension, NULL);

                if (!NT_SUCCESS(status))
                {
                    break;
                }

                // now fill the DeviceRelations structure
                TRACE("Reporting %u partitions\n", fdoExtension->EnumeratedPartitionsTotal);

                PDEVICE_RELATIONS deviceRelations =
                    ExAllocatePoolWithTag(PagedPool,
                                          sizeof(DEVICE_RELATIONS)
                                          + sizeof(PDEVICE_OBJECT)
                                          * (fdoExtension->EnumeratedPartitionsTotal - 1),
                                          TAG_PARTMGR);

                if (!deviceRelations)
                {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                deviceRelations->Count = 0;

                PSINGLE_LIST_ENTRY curEntry = fdoExtension->PartitionList.Next;
                while (curEntry != NULL)
                {
                    PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry,
                                                                     PARTITION_EXTENSION,
                                                                     ListEntry);

                    // mark the PDO to know that we don't need to manually delete it
                    partExt->IsEnumerated = TRUE;
                    deviceRelations->Objects[deviceRelations->Count++] = partExt->DeviceObject;
                    ObReferenceObject(partExt->DeviceObject);

                    curEntry = partExt->ListEntry.Next;
                }

                ASSERT(deviceRelations->Count == fdoExtension->EnumeratedPartitionsTotal);

                PartMgrReleaseLayoutLock(fdoExtension);

                Irp->IoStatus.Information = (ULONG_PTR)deviceRelations;
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }

            IoCopyCurrentIrpStackLocationToNext(Irp);
            return IoCallDriver(fdoExtension->LowerDevice, Irp);
        }
        case IRP_MN_SURPRISE_REMOVAL:
        {
            // all enumerated child devices should receive IRP_MN_REMOVE_DEVICE
            // removing only non-enumerated ones here
            for (PSINGLE_LIST_ENTRY curEntry = fdoExtension->PartitionList.Next;
                 curEntry != NULL;
                 curEntry = curEntry->Next)
            {
                PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry,
                                                                 PARTITION_EXTENSION,
                                                                 ListEntry);

                if (partExt->IsEnumerated)
                {
                    PartMgrRemovePartition(partExt, TRUE);
                }
            }

            // Send the IRP down the stack
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            return IoCallDriver(fdoExtension->LowerDevice, Irp);
        }
        case IRP_MN_REMOVE_DEVICE:
        {
            for (PSINGLE_LIST_ENTRY curEntry = fdoExtension->PartitionList.Next;
                 curEntry != NULL;
                 curEntry = curEntry->Next)
            {
                PPARTITION_EXTENSION partExt = CONTAINING_RECORD(curEntry,
                                                                 PARTITION_EXTENSION,
                                                                 ListEntry);

                ASSERT(partExt->DeviceRemoved);
            }

            // Send the IRP down the stack
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            status = IoCallDriver(fdoExtension->LowerDevice, Irp);

            IoDetachDevice(fdoExtension->LowerDevice);
            IoDeleteDevice(DeviceObject);
            return status;
        }
        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
        case IRP_MN_STOP_DEVICE:
        {
            Irp->IoStatus.Status = STATUS_SUCCESS;
            // fallthrough
        }
        default:
        {
            IoSkipCurrentIrpStackLocation(Irp);
            return IoCallDriver(fdoExtension->LowerDevice, Irp);
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

static
NTSTATUS
NTAPI
PartMgrReadWrite(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PPARTITION_EXTENSION partExt = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION ioStack = IoGetCurrentIrpStackLocation(Irp);

    if (!partExt->IsFDO)
    {
        ioStack->Parameters.Read.ByteOffset.QuadPart += partExt->StartingOffset;
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }
    else
    {
        IoSkipCurrentIrpStackLocation(Irp);
    }

    return IoCallDriver(partExt->LowerDevice, Irp);
}

DRIVER_DISPATCH PartMgrPower;
NTSTATUS
NTAPI
PartMgrPower(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    PPARTITION_EXTENSION partExt = DeviceObject->DeviceExtension;

    if (!partExt->IsFDO)
    {
        PoStartNextPowerIrp(Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }
    else
    {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(partExt->LowerDevice, Irp);
    }
}

DRIVER_DISPATCH PartMgrShutdownFlush;
NTSTATUS
NTAPI
PartMgrShutdownFlush(
    _In_ PDEVICE_OBJECT DeviceObject,
    _In_ PIRP Irp)
{
    BOOLEAN isFdo = *(PBOOLEAN)DeviceObject->DeviceExtension;

    // forward to the partition0 device in both cases
    if (!isFdo)
    {
        PPARTITION_EXTENSION partExt = DeviceObject->DeviceExtension;
        PFDO_EXTENSION fdoExtension = partExt->LowerDevice->DeviceExtension;

        IoCopyCurrentIrpStackLocationToNext(Irp);
        return IoCallDriver(fdoExtension->LowerDevice, Irp);
    }
    else
    {
        return ForwardIrpAndForget(DeviceObject, Irp);
    }
}


NTSTATUS
NTAPI
DriverEntry(
    _In_ PDRIVER_OBJECT DriverObject,
    _In_ PUNICODE_STRING RegistryPath)
{
    DriverObject->DriverUnload = PartMgrUnload;
    DriverObject->DriverExtension->AddDevice = PartMgrAddDevice;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = ForwardIrpAndForget;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = ForwardIrpAndForget;
    DriverObject->MajorFunction[IRP_MJ_READ]           = PartMgrReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = PartMgrReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = PartMgrDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = PartMgrPnp;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]       = PartMgrShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS]  = PartMgrShutdownFlush;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = PartMgrPower;

    return STATUS_SUCCESS;
}
